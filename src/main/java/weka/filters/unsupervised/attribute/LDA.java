/*
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 *    LDA.java
 *
 */


package weka.filters.unsupervised.attribute;

import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Vector;

import bridge.LdaBridge;
import bridge.parameters.ImporterParam;
import bridge.parameters.InfererParam;
import bridge.parameters.TrainerParam;
import weka.core.*;
import weka.core.Capabilities.Capability;
import weka.core.logging.Logger;
import weka.core.stemmers.NullStemmer;
import weka.core.stemmers.Stemmer;
import weka.filters.Filter;
import weka.filters.UnsupervisedFilter;

/**
 <!-- globalinfo-start -->
 * Converts string atributes into a set of numeric attributes representing topic distribution
 * from the text contained in the strings. The number of topics is determined from the attribute numTopics.
 * This attribute can be modified by the user.
 * <br><br>
 <!-- globalinfo-end -->
 * 
 <!-- options-start -->
 * <pre>-num-topics
 * Specifies number of Topics (default: 10) </pre>
 * 
 * <pre>-num-top-words
 * The number of most probable words to print for each topic after model estimation.
 * (default: 20)</pre>
 * 
 * <pre>-num-threads
 * The number of threads for parallel training. (default: 1)</pre>
 * 
 * <pre>-num-iterations
 * The number of iterations of Gibbs sampling. (default: 1000)</pre>
 * 
 * <pre>-alpha
 * SumAlpha parameter: sum over topics of smoothing over doc-topic distributions. 
 * alpha_k = [this value] / [num topics] (default: 0.5)</pre>
 * 
 * <pre>-beta
 * Beta parameter: smoothing parameter for each topic-word. beta_w = [this value](default: 0.01)</pre>
 * 
 * <pre>-burn-in
 * The number of iterations to run before first estimating dirichlet hyperparameters. (default: 200)</pre>
 * 
 * <pre> -stemmer &lt;spec&gt;
 * The stemming algorithm (classname plus parameters) to use.</pre>
 * 
 <!-- options-end -->
 * @author Pedro Celard (pedrocelard@gmail.com)
 * @version $Revision$
 */
public class LDA extends Filter 
	implements UnsupervisedFilter, OptionHandler, WeightedInstancesHandler {

	/** Autogenerated for serialization. */
	private static final long serialVersionUID = 946885311304041797L;
		
	protected LdaBridge ldaBridge = new LdaBridge();		
	
	/**
	 * Default constructor
	 */
	public LDA() {
	}
	
	
	/**
	 * Returns a string describing this filter.
	 *
	 * @return a description of the filter suitable for displaying in the
	 *         explorer/experimenter gui
	 */
	public String globalInfo() {
	  return "Converts string atributes into a set of numeric attributes representing topic distribution\n" + 
	  		" from the text contained in the strings. The number of topics is determined from the attribute numTopics.\n" + 
	  		" This attribute can be modified by the user.";
	}
	  
	/**
	 * Returns an enumeration describing the available options.
	 * 
	 * @return an enumeration of all the available options
	 */
	@Override
	public Enumeration<Option> listOptions(){
		
		Vector<Option> result = new Vector<Option>();
 
	    result.addElement(new Option(
	            "\tSpecifies number of Topics\n" + "\t(default: 10)", "num-topics", 1,
	            "-num-topics <numTopics>"));
	    
	    
	    result.addElement(new Option(
	            "\tThe number of most probable words to print for each topic after model estimation.\n" + "\t(default: 20)", "num-top-words", 1,
	            "-num-top-words <numTopWords>"));
	    
	    
	    result.addElement(new Option(
	            "\tThe number of threads for parallel training.\n" + "\t(default: 1)", "num-threads", 1,
	            "-num-threads <numThreads>"));
	    
	    
	    result.addElement(new Option(
	            "\tThe number of iterations of Gibbs sampling.\n" + "\t(default: 1000)", "num-iterations", 1,
	            "-num-iterations <numIterations>"));
	    
	    
	    result.addElement(new Option(
	            "\tSumAlpha parameter: sum over topics of smoothing over doc-topic distributions. alpha_k = [this value] / [num topics]\n" + "\t(default: 0.5)", "alpha", 1,
	            "-alpha <alpha>"));
	    
	    
	    result.addElement(new Option(
	            "\tBeta parameter: smoothing parameter for each topic-word. beta_w = [this value]\n" + "\t(default: 0.01)", "beta", 1,
	            "-beta <beta>"));
	    
	    
	    result.addElement(new Option(
	            "\tThe number of iterations to run before first estimating dirichlet hyperparameters.\n" + "\t(default: 200)", "burn-in", 1,
	            "-burn-in <burnIn>"));
	    
	    result.addElement(new Option(
	    	    "\tThe stemming algorithm (classname plus parameters) to use.",
	    	    "stemmer", 1, "-stemmer <spec>"));
	    
		return result.elements();
	}
	
	
	/**
	 * Returns the tip text for this property.
	 *
	 * @return tip text for this property suitable for displaying in the
	 *         explorer/experimenter gui
	 */
	public String numTopicsTipText() {
		return "The number of topics to fit";
	}
	
	/**
	 * Gets the number of topics to fit.
	 * 
	 * @return the number of topics to fit
	 */
	public int getNumTopics() {
		return ldaBridge.getNumTopics();
	}

	/**
	 * 
	 * Sets the number of topics to fit.
	 * 
	 * @param numTopics the number of topics to fit
	 */
	public void setNumTopics(int numTopics) {
		ldaBridge.setNumTopics(numTopics);
	}

	/**
	 * Returns the tip text for this property.
	 *
	 * @return tip text for this property suitable for displaying in the
	 *         explorer/experimenter gui
	 */
	public String numTopWordsTipText() {
		return "The number of most probable words to print for each topic after model estimation.";
	}
	
	/**
	 * Returns the number of most probable words to print for each topic after model estimation.
	 * 
	 * @return The number of most probable words to print for each topic after model estimation.
	 */
	public int getNumTopWords() {
		return ldaBridge.getNumTopWords();
	}

	/**
	 * Sets the number of most probable words to print for each topic after model estimation.
	 * 
	 * @param numTopWords the number of most probable words to print for each topic after model estimation.
	 */
	public void setNumTopWords(int numTopWords) {
		ldaBridge.setNumTopWords(numTopWords);
	}

	/**
	 * Returns the tip text for this property.
	 *
	 * @return tip text for this property suitable for displaying in the
	 *         explorer/experimenter gui
	 */
	public String numThreadsTipText() {
		return "The number of threads for parallel training.";
	}
	
	/**
	 * Returns the number of threads for parallel training.
	 * 
	 * @return the number of threads for parallel training.
	 */
	public int getNumThreads() {
		return ldaBridge.getNumThreads();
	}

	/**
	 * Sets the number of threads for parallel training.
	 * @param numThreads the number of threads for parallel training.
	 */
	public void setNumThreads(int numThreads) {
		ldaBridge.setNumThreads(numThreads);
	}

	/**
	 * Returns the tip text for this property.
	 *
	 * @return tip text for this property suitable for displaying in the
	 *         explorer/experimenter gui
	 */
	public String numIterationsTipText() {
		return "The number of iterations of Gibbs sampling.";
	}
	
	/**
	 * Returns the number of iterations of Gibbs sampling.
	 * 
	 * @return the number of iterations of Gibbs sampling.
	 */
	public int getNumIterations() {
		return ldaBridge.getNumIterations();
	}

	/**
	 * Sets the number of iterations of Gibbs sampling.
	 * @param numIterations the number of iterations of Gibbs sampling.
	 */
	public void setNumIterations(int numIterations) {
		ldaBridge.setNumIterations(numIterations);
	}

	/**
	 * Returns the tip text for this property.
	 *
	 * @return tip text for this property suitable for displaying in the
	 *         explorer/experimenter gui
	 */
	public String alphaTipText() {
		return "SumAlpha parameter: sum over topics of smoothing over doc-topic distributions. "
				+ "alpha_k = [this value] / [num topics] ";
	}
	
	/**
	 * Returns SumAlpha parameter: sum over topics of smoothing over doc-topic distributions. alpha_k = [this value] / [num topics] 
	 *
	 * @return SumAlpha parameter: sum over topics of smoothing over doc-topic distributions. alpha_k = [this value] / [num topics] 
	 */
	public double getAlpha() {
		return ldaBridge.getAlpha();
	}

	/**
	 * Sets SumAlpha parameter: sum over topics of smoothing over doc-topic distributions. alpha_k = [this value] / [num topics] 
	 * 
	 * @param alpha sum over topics of smoothing over doc-topic distributions. alpha_k = [this value] / [num topics] 
	 */
	public void setAlpha(double alpha) {
		ldaBridge.setAlpha(alpha);
	}

	/**
	 * Returns the tip text for this property.
	 *
	 * @return tip text for this property suitable for displaying in the
	 *         explorer/experimenter gui
	 */
	public String betaTipText() {
		return "Beta parameter: smoothing parameter for each topic-word. "
				+ "beta_w = [this value]";
	}
	
	/**
	 * Returns Beta parameter: smoothing parameter for each topic-word. beta_w = [this value]
	 * 
	 * @return Beta parameter: smoothing parameter for each topic-word. beta_w = [this value]
	 */
	public double getBeta() {
		return ldaBridge.getBeta();
	}

	/**
	 * Sets Beta parameter: smoothing parameter for each topic-word. beta_w = [this value]
	 * @param beta smoothing parameter for each topic-word. beta_w = [this value]
	 */
	public void setBeta(double beta) {
		ldaBridge.setBeta(beta);
	}

	/**
	 * Returns the tip text for this property.
	 *
	 * @return tip text for this property suitable for displaying in the
	 *         explorer/experimenter gui
	 */
	public String burnInTipText() {
		return "The number of iterations to run before first estimating dirichlet hyperparameters.";
	}
	
	/**
	 * Returns the number of iterations to run before first estimating dirichlet hyperparameters.
	 * 
	 * @return the number of iterations to run before first estimating dirichlet hyperparameters.
	 */
	public int getBurnIn() {
		return ldaBridge.getBurnIn();
	}

	/**
	 * Sets the number of iterations to run before first estimating dirichlet hyperparameters.
	 * @param burnIn the number of iterations to run before first estimating dirichlet hyperparameters.
	 */
	public void setBurnIn(int burnIn) {
		ldaBridge.setBurnIn(burnIn);
	}

	/**
	 * Returns the tip text for this property.
	 *
	 * @return tip text for this property suitable for displaying in the
	 *         explorer/experimenter gui
	 */
	public String stemmerTipText() {
	  return "The stemming algorithm to use on the words.";
	}
	  
	/**
	* the stemming algorithm to use, null means no stemming at all (i.e., the
	* NullStemmer is used).
	*
	* @param value the configured stemming algorithm, or null
	* @see NullStemmer
	*/
	public void setStemmer(Stemmer value) {
	  if (value != null) {
		  ldaBridge.setStemmer(value);
	  } else {
		  ldaBridge.setStemmer(new NullStemmer());
	  }
	}
	
	/**
	 * Returns the current stemming algorithm, null if none is used.
	 *
	 * @return the current stemming algorithm, null if none set
	 */
	public Stemmer getStemmer() {
	  return ldaBridge.getStemmer();
	}
	
	/**
	 * Returns the revision string.
	 *
	 * @return the revision
	 */
	@Override
	public String getRevision() {
		return RevisionUtils.extract("$Revision$");
	}
	
	/**
	 * Main method for testing this class.
	 *
	 * @param argv should contain arguments to the filter: use -h for help
	 */
	public static void main(String[] argv) {
	  runFilter(new LDA(), argv);
	}
	
	/**
	 * <!-- options-start -->
	 * Valid options are: <p>
	 * 
	 * <pre>-num-topics
	 * Specifies number of Topics (default: 10) </pre>
	 * 
	 * <pre>-num-top-words
	 * The number of most probable words to print for each topic after model estimation.
	 * (default: 20)</pre>
	 * 
	 * <pre>-num-threads
	 * The number of threads for parallel training. (default: 1)</pre>
	 * 
	 * <pre>-num-iterations
	 * The number of iterations of Gibbs sampling. (default: 1000)</pre>
	 * 
	 * <pre>-alpha
	 * SumAlpha parameter: sum over topics of smoothing over doc-topic distributions. 
	 * alpha_k = [this value] / [num topics] (default: 0.5)</pre>
	 * 
	 * <pre>-beta
	 * Beta parameter: smoothing parameter for each topic-word. beta_w = [this value](default: 0.01)</pre>
	 * 
	 * <pre>-burn-in
	 * The number of iterations to run before first estimating dirichlet hyperparameters. (default: 200)</pre>
	 * 
	 * <pre> -stemmer &lt;spec&gt;
	 *  The stemming algorithm (classname plus parameters) to use.</pre>
	 <!-- options-end -->
	 *
	 * @param options the list of options as an array of strings
	 * @throws Exception if an option is not supported
	 */
	@Override
	public void setOptions(String[] options) throws Exception {
		
		String value = Utils.getOption("num-topics", options);
		if (value.length() != 0) {
			setNumTopics(Integer.valueOf(value).intValue());
		} else {
			setNumTopics(10);
		}
		
		value = Utils.getOption("num-top-words",options);
		if (value.length() != 0) {
			setNumTopWords(Integer.valueOf(value).intValue());
		} else {
			setNumTopWords(20);
		}
		
		value = Utils.getOption("num-threads", options);
		if (value.length() != 0) {
			setNumThreads(Integer.valueOf(value).intValue());
		} else {
			setNumThreads(1);
		}
		
		value = Utils.getOption("num-iterations",options);
		if (value.length() != 0) {
			setNumIterations(Integer.valueOf(value).intValue());
		} else {
			setNumIterations(1000);
		}
		
		value = Utils.getOption("alpha",options);
		if (value.length() != 0) {
			setAlpha(Double.valueOf(value).doubleValue());
		} else {
			setAlpha(0.5);
		}
		
		value = Utils.getOption("beta",options);
		if (value.length() != 0) {
			setBeta(Double.valueOf(value).doubleValue());
		} else {
			setBeta(0.01);
		}
		
		value = Utils.getOption("burn-in",options);
		if (value.length() != 0) {
			setBurnIn(Integer.valueOf(value).intValue());
		} else {
			setBurnIn(200);
		}
		
		String stemmerString = Utils.getOption("stemmer", options);
	    if (stemmerString.length() == 0) {
	      setStemmer(null);
	    } else {
	      String[] stemmerSpec = Utils.splitOptions(stemmerString);
	      if (stemmerSpec.length == 0) {
	        throw new Exception("Invalid stemmer specification string");
	      }
	      String stemmerName = stemmerSpec[0];
	      stemmerSpec[0] = "";
	      Stemmer stemmer = (Stemmer) Utils.forName(Class.forName("weka.core.stemmers.Stemmer"), stemmerName, stemmerSpec);
	      setStemmer(stemmer);
	    }
		
		Utils.checkForRemainingOptions(options);
	}
	
	/**
	 * Gets the current settings of the filter
	 * 
	 * @return an array of string suitable for passing to setOptions
	 */
	@Override
	public String[] getOptions() {
		Vector<String> result = new Vector<String>();
		
		result.add("-num-topics");
		result.add(String.valueOf(getNumTopics()));
		
		result.add("-num-top-words");
		result.add(String.valueOf(getNumTopWords()));
		
		result.add("-num-threads");
		result.add(String.valueOf(getNumThreads()));
		
		result.add("-num-iterations");
		result.add(String.valueOf(getNumIterations()));
		
		result.add("-alpha");
		result.add(String.valueOf(getAlpha()));
		
		result.add("-beta");
		result.add(String.valueOf(getBeta()));
		
		result.add("-burn-in");
		result.add(String.valueOf(getBurnIn()));
		
	    if (getStemmer() != null) {
		    result.add("-stemmer");
		    String spec = getStemmer().getClass().getName();
		    if (getStemmer() instanceof OptionHandler) {
		      spec += " "
		        + Utils.joinOptions(((OptionHandler) getStemmer()).getOptions());
		    }
		    result.add(spec.trim());
	    }
	    
		return result.toArray(new String[result.size()]);
	}
	
	/**
	 * Returns the Capabilities of this filter.
	 *
	 * @return the capabilities of this object
	 * @see Capabilities
	 */
	@Override
	public Capabilities getCapabilities(){
		Capabilities result = super.getCapabilities();
		result.disableAll();
		
		// attributes
	    result.enableAllAttributes();
	    result.enable(Capability.MISSING_VALUES);

	    // class
	    result.enableAllClasses();
	    result.enable(Capability.MISSING_CLASS_VALUES);
	    result.enable(Capability.NO_CLASS);
	    
		return result;
	}
	
	/**
	  * Sets the format of the input instances.
	  *
	  * @param instanceInfo an Instances object containing the input instance
	  *          structure (any instances contained in the object are ignored -
	  *          only the structure is required).
	  * @return true if the outputFormat may be collected immediately
	  * @throws Exception if the input format can't be set successfully
	  */
	 @Override
	 public boolean setInputFormat(Instances instanceInfo) throws Exception {
		 super.setInputFormat(instanceInfo);
		 super.setOutputFormat(instanceInfo);
		 
		 return false;
	 }
	 
	 
	/**
	  * Input an instance for filtering. Filter requires all training instances be
	  * read before producing output.
	  *
	  * @param instance the input instance.
	  * @return true if the filtered instance may now be collected with output().
	  * @throws IllegalStateException if no input structure has been defined.
	  */
	 @Override
	 public boolean input(Instance instance) throws Exception {
		 
		 Logger.log(Logger.Level.WARNING, "Inside input");
		 
		 if(getInputFormat() == null) {
			 throw new IllegalStateException("No input stance format defined");
		 }
		 
		 if(m_NewBatch) {
			 resetQueue();
			 m_NewBatch = false;
		 }
		 
		 if(isFirstBatchDone()) {
			 
			 TrainerParam trainParam = new TrainerParam(getNumTopics(),null,null,null,null,null);
			 trainParam.setTopWords(getNumTopWords());
			 trainParam.setNumThreads(getNumThreads());
			 trainParam.setNumIterations(getNumIterations());
			 trainParam.setAlpha(getAlpha());
			 trainParam.setBeta(getBeta());
			 trainParam.setOptimizeBurnIn(getBurnIn());
			 
			 ImporterParam importParam = new ImporterParam(false);
			 //DataImport dataImp = new DataImport(importParam);
			 
			 String[] data = new String[1];
			 String[] dataClass = new String[1];
			 data[0] = instance.stringValue(0);
			 dataClass[0]  = instance.stringValue(1);
			 
			 ArrayList<Attribute> attrList = createAttributeList();

			 InfererParam inferParam = new InfererParam(null);
			 ArrayList<double[]> distributions = ldaBridge.processIntance(data,importParam,trainParam,inferParam);
			 
			 Instances resultDataInstances = new Instances("resultInstance",attrList,getInputFormat().numInstances());
			 
			 Instances inst = outputInstanceConstructor(resultDataInstances, dataClass, distributions);
			 
			 push(inst.get(0), false);
			 return true;
		 } else {
			 bufferInput(instance);
			 return false;
		 }
	 }
	 
	 
	/**
	  * Signify that this batch of input to the filter is finished. If the filter
	  * requires all instances prior to filtering, output() may now be called to
	  * retrieve the filtered instances.
	  *
	  * @return true if there are instances pending output.
	  * @throws IllegalStateException if no input structure has been defined.
	  */
	 @Override
	 public boolean batchFinished() throws Exception {
		
		 // Checks if format input exists
		 if(getInputFormat() == null) {
			 throw new IllegalStateException("No input instance format defined");
		 }
		 
	     // We only need to do something in this method
	     // if the first batch hasn't been processed. Otherwise
	     // input() has already done all the work.
		 if(!isFirstBatchDone()) {
			 
			 ImporterParam importParam = new ImporterParam(false);
		     
			 //Creates parameters
			 TrainerParam trainParam = new TrainerParam(getNumTopics(),null,null,null,null,null);
		     trainParam.setTopWords(getNumTopWords());
		     trainParam.setNumThreads(getNumThreads());
		     trainParam.setNumIterations(getNumIterations());
		     trainParam.setAlpha(getAlpha());
		     trainParam.setBeta(getBeta());
		     trainParam.setOptimizeBurnIn(getBurnIn());
		     
		     InfererParam inferParam = new InfererParam(null);
		    
			  
			 ArrayList<Attribute> attrList = createAttributeList();
		     
		     // Creates the result instances and applies output format
		     Instances resultDataInstances = new Instances("resultInstance",attrList,getInputFormat().numInstances());
			 setOutputFormat(resultDataInstances);
		     
			 /* ***************************************
			  * GETS DATA
			  * **************************************/
			 // Gets original text and class and saves it.
			 String[] data = new String[getInputFormat().numInstances()];
		     String[] dataClass = new String[getInputFormat().numInstances()];
		     
		     // Iterates obtained instances
		     int k=0;
		     for (Instance inst : getInputFormat()) {
		     	
		       String text = inst.stringValue(0);
		       String textClass = inst.stringValue(1);
		       data[k] = text;
		       dataClass[k] = textClass;
		       k++;
		     }
		     
		     
		     /* ***************************************
			  * PROCESS DATA
			  * **************************************/
		     ArrayList<double[]> distributions = ldaBridge.processBatch(data,importParam,trainParam,inferParam);
		     Instances finalInstances = outputInstanceConstructor(resultDataInstances, dataClass, distributions);
		     
	    	 for(int i=0; i < finalInstances.numInstances(); i++) {
	    	 	push(finalInstances.instance(i),false);
	    	 }
	    	 
		 }
		 
		 flushInput();
		 m_NewBatch = true;
		 m_FirstBatchDone = true;
		 return (numPendingOutput() != 0);
	 }


	 /**
	  * Create attributes to output. The number of attributes is the same as number of topics.
	  * 
	  * @return A list of attributes, one for each topic
	  */
	 private ArrayList<Attribute> createAttributeList() {
		 // Copies references to the header information from the given set of instances
		 ArrayList<Attribute> attrList = new ArrayList<>();

		 // Creates a number of attributes equals to selected number of topics 
		 for(int i=0; i<getNumTopics();i++) {
			 String attrName = "topic_"+i;
			 attrList.add(new Attribute(attrName));
		 }
		
		 // Adds one extra attribute for class
		 attrList.add(getInputFormat().attribute(1).copy("@@class@@"));
		 return attrList;
	}


	 /**
	  * Create instances from topic distributions, one instance for each document.
	  * 
	  * @param resultDataInstances Set of instances to save the individual instances into
	  * @param dataClass Set of classes from original corpus
	  * @param distributions distributions obtained from LDA to save inside each instance
	  * 
	  * @return Set of instances to output
	  */
	 private Instances outputInstanceConstructor(Instances resultDataInstances, String[] dataClass,
			ArrayList<double[]> distributions) {

		 //Gets the distributions obtained from LDA and sets them to one attribute of each instance
		 for(int e=0; e<distributions.size(); e++) {
			 DenseInstance denseInst = new DenseInstance(1,distributions.get(e));
			 denseInst.insertAttributeAt(getNumTopics());
			 denseInst.setDataset(resultDataInstances);
			 
			 //Sets the original class
			 if(!dataClass[e].equals("?")) {
				 denseInst.setValue(ldaBridge.getNumTopics(), dataClass[e]);
			 }
			 
			 //Adds each individual instance to the instace set.
			 resultDataInstances.add(denseInst);
	    	
		 }

		 // Denote the class attribute.
		 resultDataInstances.setClassIndex(resultDataInstances.numAttributes()-1);
	
		 return resultDataInstances;
	}
	 
	 
}


































